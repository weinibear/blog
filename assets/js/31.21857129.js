(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{313:function(e,r,a){"use strict";a.r(r);var t=a(14),s=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"_2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2"}},[e._v("#")]),e._v(" 2")]),e._v(" "),r("h4",{attrs:{id:"_1-进程和线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程和线程"}},[e._v("#")]),e._v(" 1.进程和线程")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("- 工厂的资源 -> 系统分配的内存（独立的一块内存）\n\n- 工厂之间的相互独立 -> 进程之间相互独立\n\n- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务\n\n- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成\n\n- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\n")])])]),r("ul",[r("li",[e._v("进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）")]),e._v(" "),r("li",[e._v("线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）")])]),e._v(" "),r("h4",{attrs:{id:"_2-浏览器是多进程的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-浏览器是多进程的"}},[e._v("#")]),e._v(" 2.浏览器是多进程的")]),e._v(" "),r("p",[e._v("每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。(浏览器应该也有自己的优化机制，有时候打开多个 tab 页后，可以在 Chrome 任务管理器中看到，有些进程被合并)")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("1. Browser进程：浏览器的主进程（负责协调、主控），只有一个\n\t负责浏览器界面显示，与用户交互。如前进，后退等\n\t负责各个页面的管理，创建和销毁其他进程\n\t将Renderer进程得到的内存中的Bitmap，绘制到用户界面上\n\t网络资源的管理，下载等\n2. 第三方插件进程：每种类型的插件对应一个进程\n3. GPU进程：最多一个，用于3D绘制等\n4. 浏览器渲染进程（浏览器内核）（即Renderer进程，内部是多线程的）\n\t主要作用：页面渲染，脚本执行，事件处理等\n")])])]),r("p",[r("strong",[e._v("在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）")])]),e._v(" "),r("p",[r("img",{attrs:{src:"/home/weini/.config/Typora/typora-user-images/image-20210621103157404.png",alt:"image-20210621103157404"}})]),e._v(" "),r("h4",{attrs:{id:"_3-渲染进程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-渲染进程"}},[e._v("#")]),e._v(" 3.渲染进程")]),e._v(" "),r("p",[e._v("​ 我们常说的浏览器内核，其实是指浏览器的渲染引擎（Rendering Engine）。渲染引擎包括有 Html 解释器、CSS 解释器、布局 Layout 和 JavaScript 引擎。最开始渲染引擎和 JavaScript 引擎并没有很明确的区分，只是随着 Web 技术的发展，JavaScript 引擎越来越独立。")]),e._v(" "),r("h5",{attrs:{id:"gui-渲染线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gui-渲染线程"}},[e._v("#")]),e._v(" GUI 渲染线程")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("+ 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。\n+ 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行\n+ GUI渲染线程与JS引擎线程是互斥的\n")])])]),r("h5",{attrs:{id:"js-引擎线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js-引擎线程"}},[e._v("#")]),e._v(" JS 引擎线程")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("+ 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）\n+ 负责解析Javascript脚本，运行代码。\n+ JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序\n+ **GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n")])])]),r("h5",{attrs:{id:"事件触发线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件触发线程"}},[e._v("#")]),e._v(" 事件触发线程")]),e._v(" "),r("ul",[r("li",[e._v("归属于浏览器而不是 JS 引擎，用来控制"),r("strong",[e._v("事件循环")]),e._v("（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）")]),e._v(" "),r("li",[e._v("当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中")]),e._v(" "),r("li",[e._v("当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理")])]),e._v(" "),r("h5",{attrs:{id:"定时触发器线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定时触发器线程"}},[e._v("#")]),e._v(" 定时触发器线程")]),e._v(" "),r("ul",[r("li",[e._v("传说中的"),r("code",[e._v("setInterval")]),e._v("与"),r("code",[e._v("setTimeout")]),e._v("所在线程")]),e._v(" "),r("li",[e._v("浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）")]),e._v(" "),r("li",[e._v("通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）")])]),e._v(" "),r("h5",{attrs:{id:"异步-http-请求线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步-http-请求线程"}},[e._v("#")]),e._v(" 异步 http 请求线程")]),e._v(" "),r("ul",[r("li",[e._v("在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求")]),e._v(" "),r("li",[e._v("将检测到状态变更时，如果设置有回调函数，异步线程就"),r("strong",[e._v("产生状态变更事件")]),e._v("，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。")])]),e._v(" "),r("h4",{attrs:{id:"_4-browser-进程和浏览器内核-renderer-进程-的通信过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-browser-进程和浏览器内核-renderer-进程-的通信过程"}},[e._v("#")]),e._v(" 4.Browser 进程和浏览器内核（Renderer 进程）的通信过程")]),e._v(" "),r("p",[e._v("打开一个浏览器，就可以看到："),r("strong",[e._v("任务管理器中出现了两个进程（一个是主控进程，一个则是打开 Tab 页的渲染进程）")])]),e._v(" "),r("p",[e._v("Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程")]),e._v(" "),r("p",[e._v("Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染")]),e._v(" "),r("ul",[r("li",[e._v("渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染")]),e._v(" "),r("li",[e._v("当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）")]),e._v(" "),r("li",[e._v("最后 Render 进程将结果传递给 Browser 进程")])]),e._v(" "),r("p",[e._v("Browser 进程接收到结果并将结果绘制出来")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("GUI渲染线程与JS引擎线程互斥 --\x3e　JS如果执行时间过长就会阻塞页面。\n--\x3e 假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\n")])])]),r("h4",{attrs:{id:"_5-webworker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-webworker"}},[e._v("#")]),e._v(" 5. WebWorker")]),e._v(" "),r("p",[e._v("JS 就真的对 cpu 密集型计算无能为力么？")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面\n一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件\n这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window\n因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误\n")])])]),r("ul",[r("li",[r("p",[e._v("创建 Worker 时，JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作 DOM）")])]),e._v(" "),r("li",[r("p",[e._v("JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）")]),e._v(" "),r("p",[e._v("如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!")]),e._v(" "),r("p",[e._v("而且注意下，"),r("strong",[e._v("JS 引擎是单线程的")]),e._v("，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。")])])]),e._v(" "),r("h4",{attrs:{id:"_6-eventloop-与渲染更新"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-eventloop-与渲染更新"}},[e._v("#")]),e._v(" 6.eventloop 与渲染更新")])])}),[],!1,null,null,null);r.default=s.exports}}]);