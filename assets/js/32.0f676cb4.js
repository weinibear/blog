(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{315:function(e,v,_){"use strict";_.r(v);var t=_(14),a=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h5",{attrs:{id:"async-和-defer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#async-和-defer"}},[e._v("#")]),e._v(" async 和 defer")]),e._v(" "),v("ul",[v("li",[e._v("相同点: "),v("strong",[e._v("异步加载 (fetch)")])]),e._v(" "),v("li",[e._v("不同点:\n"),v("ul",[v("li",[e._v("async 加载(fetch)完成后立即执行 (execution)；")]),e._v(" "),v("li",[e._v("defer 加载(fetch)完成后延迟到 DOM 解析完成后才会执行(execution)**，但会在事件 "),v("code",[e._v("DomContentLoaded")]),e._v(" 之前")])])])]),e._v(" "),v("h5",{attrs:{id:"渲染过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程"}},[e._v("#")]),e._v(" 渲染过程")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("JavaScript 的加载、解析与执行会阻塞 DOM 的构建，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停构建 DOM，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复 DOM 构建。")])]),e._v(" "),v("li",[v("p",[e._v("JS 文件不只是阻塞 DOM 的构建，它会导致 CSSOM 也阻塞 DOM 的构建。")]),e._v(" "),v("p",[e._v("因为 JavaScript 不只是可以改 DOM，它还可以更改样式，也就是它可以更改 CSSOM。不完整的 CSSOM 是无法使用的，但 JavaScript 中想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到完整的 CSSOM.所以就导致了一个现象，如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建")]),e._v(" "),v("p",[v("strong",[e._v("这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后在继续构建 DOM")]),e._v("。")])])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("CSSOM会阻塞渲染，只有当CSSOM构建完毕后才会进入下一个阶段构建渲染树。\n\n通常情况下DOM和CSSOM是并行构建的，但是当浏览器遇到一个script标签时，DOM构建将暂停，直至脚本完成执行。但由于JavaScript可以修改CSSOM，所以需要等CSSOM构建完毕后再执行JS。\n")])])]),v("ul",[v("li",[v("code",[e._v("HTML")]),e._v(","),v("code",[e._v("SVG")]),e._v(","),v("code",[e._v("XHTML")]),e._v("，解析生成"),v("code",[e._v("DOM")]),e._v("树。\n"),v("ul",[v("li",[v("code",[e._v("CSS")]),e._v("解析生成"),v("code",[e._v("CSS")]),e._v("规则树。")])])]),e._v(" "),v("li",[v("code",[e._v("JavaScript")]),e._v("用来操作"),v("code",[e._v("DOM API")]),e._v("和"),v("code",[e._v("CSSOM API")]),e._v("，生成"),v("code",[e._v("DOM Tree")]),e._v("和"),v("code",[e._v("CSSOM API")]),e._v("。")])]),e._v(" "),v("p",[e._v("解析完成后，浏览器会通过已经解析好的"),v("code",[e._v("DOM Tree")]),e._v(" 和 "),v("code",[e._v("CSS")]),e._v("规则树来构造 "),v("code",[e._v("Rendering")]),e._v(" "),v("code",[e._v("Tree")]),e._v("。")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("Rendering Tree")]),e._v(" 渲染树并不等同于"),v("code",[e._v("DOM")]),e._v("树，因为一些像"),v("code",[e._v("Header")]),e._v("或"),v("code",[e._v("display:none")]),e._v("的东西就没必要放在渲染树中了。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("CSS")]),e._v(" 的 "),v("code",[e._v("Rule Tree")]),e._v("主要是为了完成匹配并把"),v("code",[e._v("CSS Rule")]),e._v("附加上"),v("code",[e._v("Rendering")]),e._v("。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("Tree")]),e._v("上的每个"),v("code",[e._v("Element")]),e._v("。也就是"),v("code",[e._v("DOM")]),e._v("结点，即"),v("code",[e._v("Frame")]),e._v("。然后，计算每个"),v("code",[e._v("Frame")]),e._v("（也就是每个"),v("code",[e._v("Element")]),e._v("）的位置，这又叫"),v("code",[e._v("layout")]),e._v("和"),v("code",[e._v("reflow")]),e._v("过程。")])]),e._v(" "),v("li",[v("p",[e._v("最后通过调用操作系统"),v("code",[e._v("Native GUI")]),e._v("的"),v("code",[e._v("API")]),e._v("绘制。")])])]),e._v(" "),v("h5",{attrs:{id:"回流-reflow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow"}},[e._v("#")]),e._v(" 回流（"),v("code",[e._v("Reflow")]),e._v("）")]),e._v(" "),v("p",[e._v("当"),v("code",[e._v("Render Tree")]),e._v("中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。")]),e._v(" "),v("p",[e._v("会导致回流的操作：")]),e._v(" "),v("ul",[v("li",[e._v("页面首次渲染")]),e._v(" "),v("li",[e._v("浏览器窗口大小发生改变")]),e._v(" "),v("li",[e._v("元素尺寸或位置发生改变")]),e._v(" "),v("li",[e._v("元素内容变化（文字数量或图片大小等等）")]),e._v(" "),v("li",[e._v("元素字体大小变化")]),e._v(" "),v("li",[e._v("添加或者删除"),v("strong",[e._v("可见")]),e._v("的"),v("code",[e._v("DOM")]),e._v("元素")]),e._v(" "),v("li",[e._v("激活"),v("code",[e._v("CSS")]),e._v("伪类（例如："),v("code",[e._v(":hover")]),e._v("）")]),e._v(" "),v("li",[e._v("查询某些属性或调用某些方法")])]),e._v(" "),v("p",[e._v("一些常用且会导致回流的属性和方法：")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("clientWidth")]),e._v("、"),v("code",[e._v("clientHeight")]),e._v("、"),v("code",[e._v("clientTop")]),e._v("、"),v("code",[e._v("clientLeft")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("offsetWidth")]),e._v("、"),v("code",[e._v("offsetHeight")]),e._v("、"),v("code",[e._v("offsetTop")]),e._v("、"),v("code",[e._v("offsetLeft")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("scrollWidth")]),e._v("、"),v("code",[e._v("scrollHeight")]),e._v("、"),v("code",[e._v("scrollTop")]),e._v("、"),v("code",[e._v("scrollLeft")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("scrollIntoView()")]),e._v("、"),v("code",[e._v("scrollIntoViewIfNeeded()")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("getComputedStyle()")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("getBoundingClientRect()")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("scrollTo()")])])])]),e._v(" "),v("p",[v("strong",[e._v("重排")]),e._v("意味着元件的几何尺寸变了，我们需要重新验证并计算"),v("code",[e._v("Render Tree")]),e._v("。是"),v("code",[e._v("Render Tree")]),e._v("的一部分或全部发生了变化。这就是"),v("code",[e._v("Reflow")]),e._v("，或是"),v("code",[e._v("Layout")]),e._v("。")]),e._v(" "),v("h5",{attrs:{id:"重绘-repaint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[e._v("#")]),e._v(" 重绘 (Repaint)")]),e._v(" "),v("p",[e._v("当页面中元素样式的改变并不影响它在文档流中的位置时（例如："),v("code",[e._v("color")]),e._v("、"),v("code",[e._v("background-color")]),e._v("、"),v("code",[e._v("visibility")]),e._v("等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('\nvar bstyle = document.body.style; // cache\n\nbstyle.padding = "20px"; // reflow, repaint\nbstyle.border = "10px solid red"; //  再一次的 reflow 和 repaint\n\nbstyle.color = "blue"; // repaint\nbstyle.backgroundColor = "#fad"; // repaint\n\nbstyle.fontSize = "2em"; // reflow, repaint\n\n// new DOM element - reflow, repaint\ndocument.body.appendChild(document.createTextNode(\'dude!\'));\n')])])]),v("h5",{attrs:{id:"浏览器的优化机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的优化机制"}},[e._v("#")]),e._v(" 浏览器的优化机制")]),e._v(" "),v("p",[e._v("现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！"),v("strong",[e._v("当你获取布局信息的操作的时候，会强制队列刷新")]),e._v("，强制重排，比如当你访问以下属性或者使用以下方法：")]),e._v(" "),v("ul",[v("li",[e._v("offsetTop、offsetLeft、offsetWidth、offsetHeight")]),e._v(" "),v("li",[e._v("scrollTop, scrollLeft, scrollWidth, scrollHeight")]),e._v(" "),v("li",[e._v("clientTop, clientLeft, clientWidth, clientHeight")]),e._v(" "),v("li",[e._v("getComputedStyle()等")])]),e._v(" "),v("p",[e._v("以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。")]),e._v(" "),v("h5",{attrs:{id:"性能影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能影响"}},[e._v("#")]),e._v(" 性能影响")]),e._v(" "),v("p",[v("strong",[e._v("回流比重绘的代价要更高。")])]),e._v(" "),v("p",[e._v("有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。")]),e._v(" "),v("p",[e._v("现代浏览器会对频繁的回流或重绘操作进行优化：")]),e._v(" "),v("p",[e._v("浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。")]),e._v(" "),v("h5",{attrs:{id:"如何避免"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何避免"}},[e._v("#")]),e._v(" 如何避免")]),e._v(" "),v("h6",{attrs:{id:"css"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[e._v("#")]),e._v(" CSS")]),e._v(" "),v("ul",[v("li",[e._v("避免使用"),v("code",[e._v("table")]),e._v("布局。")]),e._v(" "),v("li",[e._v("尽可能在"),v("code",[e._v("DOM")]),e._v("树的最末端改变"),v("code",[e._v("class")]),e._v("。")]),e._v(" "),v("li",[e._v("避免设置多层内联样式。")]),e._v(" "),v("li",[e._v("将动画效果应用到"),v("code",[e._v("position")]),e._v("属性为"),v("code",[e._v("absolute")]),e._v("或"),v("code",[e._v("fixed")]),e._v("的元素上。")]),e._v(" "),v("li",[e._v("避免使用"),v("code",[e._v("CSS")]),e._v("表达式（例如："),v("code",[e._v("calc()")]),e._v("）。")])]),e._v(" "),v("h6",{attrs:{id:"javascript"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[e._v("#")]),e._v(" JavaScript")]),e._v(" "),v("ul",[v("li",[e._v("避免频繁操作样式，最好一次性重写"),v("code",[e._v("style")]),e._v("属性，或者将样式列表定义为"),v("code",[e._v("class")]),e._v("并一次性更改"),v("code",[e._v("class")]),e._v("属性。")]),e._v(" "),v("li",[e._v("避免频繁操作"),v("code",[e._v("DOM")]),e._v("，创建一个"),v("code",[e._v("documentFragment")]),e._v("，在它上面应用所有"),v("code",[e._v("DOM操作")]),e._v("，最后再把它添加到文档中。")]),e._v(" "),v("li",[e._v("也可以先为元素设置"),v("code",[e._v("display: none")]),e._v("，操作结束后再把它显示出来。因为在"),v("code",[e._v("display")]),e._v("属性为"),v("code",[e._v("none")]),e._v("的元素上进行的"),v("code",[e._v("DOM")]),e._v("操作不会引发回流和重绘。")]),e._v(" "),v("li",[e._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")]),e._v(" "),v("li",[e._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const el = document.getElementById('test');\nel.style.padding = '5px';\nel.style.borderLeft = '1px';\nel.style.borderRight = '2px';\n")])])]),v("ul",[v("li",[e._v("使用 cssText")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const el = document.getElementById('test');\nel.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';\n")])])]),v("ul",[v("li",[e._v("修改 CSS 的 class")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("const el = document.getElementById('test');\nel.className += ' active';\n")])])]),v("ul",[v("li",[e._v("批量修改 DOM")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("使元素脱离文档流\n对其进行多次修改\n将元素带回到文档中\n")])])]),v("ul",[v("li",[e._v("缓存布局信息")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("// bad 强制刷新 触发两次重排\ndiv.style.left = div.offsetLeft + 1 + 'px';\ndiv.style.top = div.offsetTop + 1 + 'px';\n\n// good 缓存布局信息 相当于读写分离\nvar curLeft = div.offsetLeft;\nvar curTop = div.offsetTop;\ndiv.style.left = curLeft + 1 + 'px';\ndiv.style.top = curTop + 1 + 'px';\n")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);