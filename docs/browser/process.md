### 2

#### 1.进程和线程

```
- 工厂的资源 -> 系统分配的内存（独立的一块内存）

- 工厂之间的相互独立 -> 进程之间相互独立

- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务

- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成

- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
```

- 进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

#### 2.浏览器是多进程的

每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。(浏览器应该也有自己的优化机制，有时候打开多个 tab 页后，可以在 Chrome 任务管理器中看到，有些进程被合并)

```
1. Browser进程：浏览器的主进程（负责协调、主控），只有一个
	负责浏览器界面显示，与用户交互。如前进，后退等
	负责各个页面的管理，创建和销毁其他进程
	将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
	网络资源的管理，下载等
2. 第三方插件进程：每种类型的插件对应一个进程
3. GPU进程：最多一个，用于3D绘制等
4. 浏览器渲染进程（浏览器内核）（即Renderer进程，内部是多线程的）
	主要作用：页面渲染，脚本执行，事件处理等
```

**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）**

![image-20210621103157404](/home/weini/.config/Typora/typora-user-images/image-20210621103157404.png)

#### 3.渲染进程

​ 我们常说的浏览器内核，其实是指浏览器的渲染引擎（Rendering Engine）。渲染引擎包括有 Html 解释器、CSS 解释器、布局 Layout 和 JavaScript 引擎。最开始渲染引擎和 JavaScript 引擎并没有很明确的区分，只是随着 Web 技术的发展，JavaScript 引擎越来越独立。

##### GUI 渲染线程

    + 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
    + 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
    + GUI渲染线程与JS引擎线程是互斥的

##### JS 引擎线程

    + 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
    + 负责解析Javascript脚本，运行代码。
    + JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
    + **GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

##### 事件触发线程

- 归属于浏览器而不是 JS 引擎，用来控制**事件循环**（可以理解，JS 引擎自己都忙不过来，需要浏览器另开线程协助）
- 当 JS 引擎执行代码块如 setTimeOut 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理

##### 定时触发器线程

- 传说中的`setInterval`与`setTimeout`所在线程
- 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
- 通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）

##### 异步 http 请求线程

- 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

#### 4.Browser 进程和浏览器内核（Renderer 进程）的通信过程

打开一个浏览器，就可以看到：**任务管理器中出现了两个进程（一个是主控进程，一个则是打开 Tab 页的渲染进程）**

Browser 进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过 RendererHost 接口传递给 Render 进程

Renderer 进程的 Renderer 接口收到消息，简单解释后，交给渲染线程，然后开始渲染

- 渲染线程接收请求，加载网页并渲染网页，这其中可能需要 Browser 进程获取资源和需要 GPU 进程来帮助渲染
- 当然可能会有 JS 线程操作 DOM（这样可能会造成回流并重绘）
- 最后 Render 进程将结果传递给 Browser 进程

Browser 进程接收到结果并将结果绘制出来

```
GUI渲染线程与JS引擎线程互斥 -->　JS如果执行时间过长就会阻塞页面。
--> 假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。
```

#### 5. WebWorker

JS 就真的对 cpu 密集型计算无能为力么？

```
Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面
一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件
这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window
因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
```

- 创建 Worker 时，JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作 DOM）

- JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

  如果有非常耗时的工作，请单独开一个 Worker 线程，这样里面不管如何翻天覆地都不会影响 JS 引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!

  而且注意下，**JS 引擎是单线程的**，这一点的本质仍然未改变，Worker 可以理解是浏览器给 JS 引擎开的外挂，专门用来解决那些大量计算问题。

#### 6.eventloop 与渲染更新
